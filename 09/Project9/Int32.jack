

class Int32{
	field Array bits;

	constructor Int32 new(int initial) {
		var Int32 plusOne;
		var int nearestPowerOfTwo, counter;
		var bool isNeg;
		let isNeg = false;
		let bits = Array.new(32);
		let counter = 0;
		while(counter < 32){
			let bits[counter] = false;
			let counter = counter + 1;
		}
		if(initial < 0){
			let isNeg = true;
			let initial = initial * -1;
		}
		while(~(initial = 0)){
			let nearestPowerOfTwo = 1;
			let counter = 0;
			while(~(initial / (nearestPowerOfTwo * 2) = 0)){
				let nearestPowerOfTwo = nearestPowerOfTwo * 2;
				let counter = counter + 1;
			}
			let bits[counter] = true;
			let initial = initial - nearestPowerOfTwo;
		}
		//do printBits();
		if(isNeg){
			do invert();
			do plusThisInt(1);
		}
		return this;   // a constructor is expected to return a reference to the new object
	}


	constructor Int32 copyNew(Array otherBits){
		var int i;
		let bits = Array.new(32);
		let i = 0;
		while(i < 32){
			let bits[i] = otherBits[i];
			let i = i + 1;
		}
		return this;
	}

	method Array getBits(){
		return bits;
	}

	method boolean negative(){
		if(bits[31] = true){
			return true;
		}
		return false;
	}


	//Simple Addition
	method Int32 plus(Int32 other){
		var Int32 toReturn;
		var Array newBits, intermediate;
		var bool carry;
		var int i, immediateSum;
		let newBits = Array.new(32);
		//let intermediate = Array.new(32);
		let carry = false;
		while(i < 32){
			let immediateSum = bits[i];
			let intermediate = other.getBits();
			let immediateSum = immediateSum + intermediate[i];
			let immediateSum = immediateSum + carry;
			if(immediateSum = 0){
				let newBits[i] = false;
				let carry = false;
			}
			if(immediateSum = -1){
				let newBits[i] = true;
				let carry = false;
			}
			if(immediateSum = -2){
				let newBits[i] = false;
				let carry = true;
			}
			if(immediateSum = -3){
				let newBits[i] = true;
				let carry = true;
			}
			let i = i + 1;
		}

		let toReturn = Int32.copyNew(newBits);
		return toReturn;
	}

	method Int32 div(Int32 other){
		var Int32 thisCopy, otherCopy, toReturn, i;
		var boolean resultNeg;
		//Copies to avoid overriding the originals
		let thisCopy = Int32.copyNew(bits);
		let otherCopy = Int32.copyNew(other.getBits());
		//Check if either number is negative
		//If the dividend is negative, negate it.
		// If the divisor is positive, negate it.
		if(negative()){
			if(other.negative()){
				let resultNeg = false;
			}
			else {
				let resultNeg = true;
				do otherCopy.invert();
				do otherCopy.plusThisInt(1);
			}
			do thisCopy.invert();
			do thisCopy.plusThisInt(1);
		}
		else{
			if(other.negative()){
				let resultNeg = true;
			}
			else {
				let resultNeg = false;
				do otherCopy.invert();
				do otherCopy.plusThisInt(1);
			}
		}
		
		let toReturn = Int32.new(0);
		let i = thisCopy.plus(otherCopy);
		while(~i.negative()){
			do thisCopy.plusThis(otherCopy);
			do toReturn.plusThisInt(1);
			let i = thisCopy.plus(otherCopy);
		}

		if(resultNeg){
			do toReturn.invert();
			do toReturn.plusThisInt(1);
		}

		return toReturn;
	}

	method Int32 mul(Int32 other){
		var Int32 thisCopy, otherCopy, toReturn;
		var boolean resultNeg;
		let toReturn = Int32.new(0);
		let thisCopy = Int32.copyNew(bits);
		let otherCopy = Int32.copyNew(other.getBits());
		if(negative()){
			if(other.negative()){
				let resultNeg = false;
				do otherCopy.invert();
				do otherCopy.plusThisInt(1);
			}
			else {
				let resultNeg = true;
			}
			do thisCopy.invert();
			do thisCopy.plusThisInt(1);
		}
		else{
			if(other.negative()){
				let resultNeg = true;
				do otherCopy.invert();
				do otherCopy.plusThisInt(1);
			}
			else {
				let resultNeg = false;
			}
		}
		//I have no method for check if a number is greater than or equal to 0, but I do have one that checks if it's negative. And, if I decrement other by 1, it should essentially function the same.
		do otherCopy.plusThisInt(-1);
		do thisCopy.printBits();
		while(~otherCopy.negative()){
			do toReturn.plusThis(thisCopy);
			do otherCopy.plusThisInt(-1);
		}

		if(resultNeg){
			do toReturn.invert();
			do toReturn.plusThisInt(1);
		}

		return toReturn;
	}

	//For adding and storing the result in this
	method void plusThis(Int32 other){
		var Array newBits, interThis, interOther;
		var bool carry;
		var int i, immediateSum;
		let newBits = Array.new(32);
		//let intermediate = Array.new(32);
		let carry = false;
		let interThis = bits;
		let interOther = other.getBits();
		while(i < 32){
			let immediateSum = interThis[i];
			let immediateSum = interThis[i] + interOther[i];
			let immediateSum = immediateSum + carry;
			if(immediateSum = 0){
				let bits[i] = false;
				let carry = false;
			}
			if(immediateSum = -1){
				let bits[i] = true;
				let carry = false;
			}
			if(immediateSum = -2){
				let bits[i] = false;
				let carry = true;
			}
			if(immediateSum = -3){
				let bits[i] = true;
				let carry = true;
			}
			let i = i + 1;
		}
		return;
	}

	//For adding 16bit integers
	method Int32 plusInt(int other){
		var Int32 int16to32;
		let int16to32 = Int32.new(other);
		return plus(int16to32);
	}

	method void plusThisInt(int other){
		var Int32 int16to32;
		let int16to32 = Int32.new(other);
		do plusThis(int16to32);
		return;
	}

	method void invert(){
		var int i;
		let i = 0;
		while(i < 32){
			let bits[i] = ~bits[i];
			let i = i + 1;
		}
		return;
	}


	//Performs an arithmatic bitshift right
	method Int32 asr(int shifts){
		var Int32 toReturn;
		var Array shiftedBits;
		var int i;
		if(negative()){
			let toReturn = Int32.new(-1);
		}
		else {
			let toReturn= Int32.new(0);
		}
		let shiftedBits = toReturn.getBits();
		//let shifts = shifts - 1;
		let i = 0;
		while(shifts < 32){
			let shiftedBits[i] = bits[shifts];
			let i = i + 1;
			let shifts = shifts + 1;
		}
		let toReturn = Int32.copyNew(shiftedBits);
		return toReturn;
	}

	// method void inc(){
	// 	let this = plusInt(1);
	// }


	//Cast to 16bit integer
	method int toInt(){
		var int i, j, toReturn, intermediate;
		var boolean isNeg;
		var Int32 copy;
		var Array copyBits;
		let toReturn = 0;
		let copy = Int32.copyNew(bits);
		let isNeg = false;
		if(bits[31] = true){
			do copy.invert();
			do copy.plusThisInt(1);
			let isNeg = true;
		}
		let copyBits = copy.getBits();
		let i = 0;
		while(i < 32){
			if(copyBits[i] = -1){
				let j = 0;
				let intermediate = 1;
				while(j < i){
					let intermediate = intermediate * 2;
					let j = j + 1;
				}
				let toReturn = toReturn + intermediate;
			}
			let i = i + 1;
		}

		if(isNeg){
			let toReturn = toReturn * -1;
		}

		return toReturn;
	}

	method void printBits(){
		var int i;
		let i = 31;
		while(i > -1){
			do Output.printInt(bits[i]);
			let i = i - 1;
		}
		do Output.println();
		return;
	}
}

// /******************************************************************************

// Welcome to GDB Online.
// GDB online is an online compiler and debugger tool for C, C++, Python, PHP, Ruby, 
// C#, VB, Perl, Swift, Prolog, Javascript, Pascal, HTML, CSS, JS
// Code, Compile, Run and Debug online from anywhere in world.

// *******************************************************************************/
// #include <stdio.h>

// #include <vector>
// #include <iostream>
// using namespace std;

// vector<bool> intToBits(int input);

// int main()
// {
//     vector<bool> test;
//     test = intToBits(2423);
//     for(int i = 31; i >= 0; i--){
//         cout << test[i] << " ";
//     }
//     cout << endl;
//     return 0;
// }

// vector<bool> intToBits(int input){
// 		int nearestPowerOfTwo, counter;
// 		bool isNeg = false;
// 		vector<bool> bits;
// 		for(int i = 0; i < 32; i++){
// 		    bits.push_back(false);
// 		}
// 		if(input < 0){
// 		    isNeg = true;
// 		    input = input *= -1
// 		}
// 		while(input > 0){
// 			nearestPowerOfTwo = 1;
// 			counter = 0;
// 			while(input / (nearestPowerOfTwo * 2) != 0){
// 				nearestPowerOfTwo = nearestPowerOfTwo * 2;
// 				counter = counter + 1;
// 			}
// 			bits.at(counter) = true;
// 			input -= nearestPowerOfTwo;
// 		}
// 		return bits;
// }


